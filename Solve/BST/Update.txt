V1.0

1.使用字典和停词分别建立完美平衡树，分别在两棵树中查找文章单词
#一次性开点情况下，速度在0.67左右

V1.1

1.使用字典建立完美平衡树，在字典的二叉树中删除停词对应的节点
#一次性开点情况下，速度在0.68左右

V1.2

1.使用字典建立完美平衡树，查找文章单词，最后根据停词标记删除
#一次性开点情况下，速度在0.66左右

V1.3

1.使用两个文章建普通二叉树，在树中查找字典和停词中的单词并标记
#一次性开点情况下，速度在0.49左右

V1.4

1.使用两个文章建平衡二叉树，在树中查找字典和停词中的单词并标记
#一次性开点情况下，速度在0.51左右

V1.5

1.使用两个文章建普通二叉树，在树中删除停词中的单词后查找字典中的单词
#一次性开点情况下，速度在0.48左右

V1.6

1.使用两个文章建平衡二叉树，在树中删除停词中的单词后查找字典中的单词
#一次性开点情况下，速度在0.51左右

V1.7

1.使用两个文章建普通二叉树，在树中查找字典和停词中的单词并标记
2.利用字典中单词具有的完备性省去DFS的过程
#一次性开点情况下，速度在0.48左右

V1.8

1.将V1.7二叉树指针写法改为数组写法
2.微调了程序结构，将处理和打印函数合并
#一次性开点情况下，速度在0.50左右

#V1.X旨在探索使用二叉树的最佳方式
#没有使用IO优化，编译优化，O(n)处理等通用优化
#综合考虑代码简洁和效率，平衡树选择SizeBalancedTree

-----------V1.X的最快速度在0.50左右-----------

V2.0

1.以V1.7为基础，重构代码，添加大量编译优化命令
2.采用切分buffer数组+反链式前向星线性检索前n大词频
3.使用fread+buffer快速读入，使用fwrite+buffer快速输出
4.优化了字母转换，字母判断，优化了变量类型与分配，尽量采用register变量
#实际测试速度在0.34左右

V2.1

1.在V2.0的基础上反向遍历字典，正向读取单词
#本地测试比V2.0快0.01秒左右

V2.2

1.在V2.0的基础上正向遍历字典，反向读取单词
#本地测试比V2.0慢0.07秒左右

V2.3

1.在V2.0的基础上反向遍历字典，反向读取单词
#本地测试比V2.0慢0.08秒左右

V2.4

1.在V2.1的基础上将递归改为循环
#本地测试比V2.1快0.05秒左右

V2.5

1.在V2.1的基础上维护父亲指针并采用循环
#本地测试比V2.1快0.10秒左右

V2.6

1.在V2.5的基础上加入红黑树的Fixins操作
#本地测试比V2.1快0.10秒左右，实测在0.30左右

V2.7

1.在V2.6的基础上加入红黑树的Fixdel操作
#本地测试比V2.1慢0.05秒左右

-----------V2.X的最快速度在0.30左右-----------